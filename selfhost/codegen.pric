# -*- mode: ruby -*-

#include lib/std.pric
#include lib/words.pric
#include lib/types.pric
#include lib/json.pric

# --------------------------------

def asm_indent()
  putchar(C_SPC());
  putchar(C_SPC());
end

def asm_exit()
  var [5]temp_str;

  aset(&temp_str, 0, 101); # e
  aset(&temp_str, 1, 120); # x
  aset(&temp_str, 2, 105); # i
  aset(&temp_str, 3, 116); # t
  aset(&temp_str, 4,   0);

  asm_indent();
  print_s(&temp_str);
  putchar(C_LF());
end

def asm_label(label_)
  var [6]temp_str;

  aset(&temp_str, 0, 108); # l
  aset(&temp_str, 1,  97); # a
  aset(&temp_str, 2,  98); # b
  aset(&temp_str, 3, 101); # e
  aset(&temp_str, 4, 108); # l
  aset(&temp_str, 5,   0);

  print_s(&temp_str);
  putchar(C_SPC());
  print_s(label_);
  putchar(C_LF());
end

def asm_call(label_)
  var [5]temp_str;

  aset(&temp_str, 0,  99); # c
  aset(&temp_str, 1,  97); # a
  aset(&temp_str, 2, 108); # l
  aset(&temp_str, 3, 108); # l
  aset(&temp_str, 4,   0);

  asm_indent();
  print_s(&temp_str);
  putchar(C_SPC());
  print_s(label_);
  putchar(C_LF());
end

def asm_ret()
  var [4]temp_str;

  aset(&temp_str, 0, 114); # r
  aset(&temp_str, 1, 101); # e
  aset(&temp_str, 2, 116); # t
  aset(&temp_str, 3,   0);

  asm_indent();
  print_s(&temp_str);
  putchar(C_LF());
end

def asm_cp(src_, dest_)
  var [3]temp_str;

  aset(&temp_str, 0,  99); # c
  aset(&temp_str, 1, 112); # p
  aset(&temp_str, 2,   0);

  asm_indent();
  print_s(&temp_str);
  putchar(C_SPC());
  print_s(src_);
  putchar(C_SPC());
  print_s(dest_);
  putchar(C_LF());
end

def asm_push(arg_)
  var [5]temp_str;

  aset(&temp_str, 0, 112); # p
  aset(&temp_str, 1, 117); # u
  aset(&temp_str, 2, 115); # s
  aset(&temp_str, 3, 104); # h
  aset(&temp_str, 4,   0);

  asm_indent();
  print_s(&temp_str);
  putchar(C_SPC());
  print_s(arg_);
  putchar(C_LF());
end

def asm_pop(dest_)
  var [4]temp_str;

  aset(&temp_str, 0, 112); # p
  aset(&temp_str, 1, 111); # o
  aset(&temp_str, 2, 112); # p
  aset(&temp_str, 3,   0);

  asm_indent();
  print_s(&temp_str);
  putchar(C_SPC());
  print_s(dest_);
  putchar(C_LF());
end

def asm_sub_sp(n)
  var [7]temp_str;

  aset(&temp_str, 0, 115); # s
  aset(&temp_str, 1, 117); # u
  aset(&temp_str, 2,  98); # b
  aset(&temp_str, 3,  95); # _
  aset(&temp_str, 4, 115); # s
  aset(&temp_str, 5, 112); # p
  aset(&temp_str, 6,   0);

  asm_indent();
  print_s(&temp_str);
  putchar(C_SPC());
  print_i(n);
  putchar(C_LF());
end

def asm_fn_prologue()
  var [10]temp_str;
  var [10]temp_str2;

  str_set_bp(&temp_str);
  asm_push(&temp_str);

  str_set_sp(&temp_str);
  str_set_bp(&temp_str2);
  asm_cp(&temp_str, &temp_str2);
end

def asm_fn_epilogue()
  var [10]temp_str;
  var [10]temp_str2;

  str_set_bp(&temp_str);
  str_set_sp(&temp_str2);
  asm_cp(&temp_str, &temp_str2);

  str_set_bp(&temp_str);
  asm_pop(&temp_str);
end

# --------------------------------

def to_fn_arg_addr(names_, name_)
  panic(166); # TODO
end

def to_lvar_addr(dest_, names_, name_)
  var idx = Names_index(names_, name_);
  assert(0, idx, 175);

  aset(dest_, 0,  91); # [
  aset(dest_, 1,  98); # b
  aset(dest_, 2, 112); # p
  aset(dest_, 3,  58); # :
  aset(dest_, 4,  45); # -

  if ((idx + 1) < 10)
    aset(dest_, 5, i_to_c(idx + 1));
  else
    # not yet supported
    panic(181);
  end

  aset(dest_, 6,  93); # ]
  aset(dest_, 7,   0);
end

# --------------------------------

def gen_var(
      g_,
      # fn_arg_names_,
      lvar_names_,
      list_
    )
  var set_stmt_;
  var [4]str_set;

  asm_sub_sp(1);

  if (NodeList_size(list_) == 3)
    str_set_set(&str_set);

    set_stmt_ = NodeList_new(g_);
    NodeList_add_str(g_, set_stmt_, &str_set);
    NodeList_add(set_stmt_, NodeList_get(list_, 1));
    NodeList_add(set_stmt_, NodeList_get(list_, 2));

    gen_set(lvar_names_, set_stmt_);
  end
end

# TODO gen_case
# TODO gen_while
# TODO _gen_expr_add
# TODO _gen_expr_mult
# TODO _gen_expr_eq
# TODO _gen_expr_neq
# TODO _gen_expr_binary

def gen_expr(
      # fn_arg_names_,
      # lvar_names_,
      expr_
    )
  var [8]cp_src;
  var [6]str_reg_a;
  var expr;

  str_set_reg_a(&str_reg_a);

  case
  when (Node_kind_eq(expr_, NODE_KIND__INT()))
    expr = Node_get_int(expr_);
    assert(42, expr, 220); # test-compile-4
    unparse_int(&cp_src, expr);
  else
    # not yet implemented
    panic(224);
  end

  asm_cp(&cp_src, &str_reg_a);
end

# TODO gen_call
# TODO gen_call_set

def gen_set(
      # fn_arg_names_,
      lvar_names_, list_
    )
  var [8]dest;
  var [8]lvar_name_;
  var [6]str_reg_a;
  var expr_node_;

  str_set_reg_a(&str_reg_a);

  lvar_name_ = NodeList_get_as_str(list_, 1);
  expr_node_ = NodeList_get(list_, 2);

  gen_expr(expr_node_);

  to_lvar_addr(
    &dest,
    lvar_names_,
    lvar_name_
  );

  asm_cp(&str_reg_a, &dest);
end

# TODO gen_return

def gen_vm_comment(list_)
  asm_indent();

  putchar( 95); # _
  putchar( 99); # c
  putchar(109); # m
  putchar(116); # t
  putchar(C_SPC()); #  
  putchar(118); # v
  putchar(109); # m
  putchar( 95); # _
  putchar( 99); # c
  putchar(111); # o
  putchar(109); # m
  putchar(109); # m
  putchar(101); # e
  putchar(110); # n
  putchar(116); # t
  putchar(C_LF());
end

def gen_stmt(
      # fn_arg_names_,
      lvar_names_,
      list_
    )
  case
  when (str_eq_set(NodeList_get_as_str(list_, 0)))
    gen_set(lvar_names_, list_);
  when (str_eq__cmt(NodeList_get_as_str(list_, 0)))
    gen_vm_comment(list_);
  else
    panic(257);
  end
end

# TODO gen_stmts

def gen_func(g_, func_)
  var fn_name_;
  var stmts_;
  var stmt_;
  var i;
  var lvar_names_;
  var lvar_name_;

  assert(4, NodeList_size(func_), 243);
  fn_name_ = Node_get_str(NodeList_get(func_, 1));
  # TODO args
  stmts_ = Node_get_list(NodeList_get(func_, 3));

  asm_label(fn_name_);

  asm_fn_prologue();

  lvar_names_ = Names_new(g_);

  i = 0;
  while (i < NodeList_size(stmts_))
    stmt_ = NodeList_get_as_list(stmts_, i);

    if (str_eq_var(NodeList_get_as_str(stmt_, 0)))
      lvar_name_ = NodeList_get_as_str(stmt_, 1);
      Names_add(lvar_names_, lvar_name_);
      gen_var(g_, lvar_names_, stmt_);
    else
      gen_stmt(lvar_names_, stmt_);
    end

    i = i + 1;
  end

  asm_fn_epilogue();

  asm_ret();
end

def gen_top_stmt(g_, top_stmt_)
  var head_ = NodeList_get(top_stmt_, 0);

  case
  when (str_eq_func(Node_get_str(head_)))
    gen_func(g_, top_stmt_);
  else
    panic(194);
  end
end

def gen_top_stmts(g_, top_stmts_)
  var i;
  var top_stmt_;

  i = 1;
  while (i < NodeList_size(top_stmts_))
    top_stmt_ = NodeList_get_as_list(top_stmts_, i);
    gen_top_stmt(g_, top_stmt_);
    i = i + 1;
  end
end

def codegen(g_, ast_)
  var [5]temp_str;

  aset(&temp_str, 0, 109); # m
  aset(&temp_str, 1,  97); # a
  aset(&temp_str, 2, 105); # i
  aset(&temp_str, 3, 110); # n
  aset(&temp_str, 4,   0);
  asm_call(&temp_str);

  asm_exit();

  gen_top_stmts(g_, ast_);
end

def INPUT_MAX() return 180; end

def main()
  var [1]g;
  var [180]input; # INPUT_MAX
  var ast_;

  # init globals
  init_alloc_cursor(&g);

  read_stdin_all(&input, INPUT_MAX());

  ast_ = Json_parse(&g, &input);

  codegen(&g, ast_);
end
